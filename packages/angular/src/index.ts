import { ComponentsGenerator, ComponentMetadata, Config, ComponentPropertyMetadata } from 'web-component-wrapper-core';
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';

interface AngularComponentsOptions {
  /**
   * The designated path for importing the web-component.
   * Generally, it points to the web-component library.
   * For instance: ({className}) => `import {${className}} from `@my-company/my-design-system`;
   * @param componentMetadata
   */
  componentImport: (componentMetadata: ComponentMetadata) => string;
  /**
   * The component's tag name.
   * For instance: ({className}) => kebabCase(className)
   * @param componentMetadata
   */
  componentTag?: (componentMetadata: ComponentMetadata) => string;
}

const kebabCase = (text: string) => text.replace(/\s+/g, '-').toLowerCase();

export class AngularComponentsGenerator implements ComponentsGenerator {
  private options: AngularComponentsOptions;

  constructor(options: AngularComponentsOptions) {
    this.options = {
      componentTag: ({ className }) => kebabCase(className),
      ...options
    }
  }

  generate(componentsMetadata: ComponentMetadata[], config: Config) {
    const angularComponents = componentsMetadata.map(componentMetadata => new AngularComponent(componentMetadata, this.options));

    [...angularComponents].forEach(item => item.generate(config))

    // console.log({
    //   componentsMetadata,
    //   config
    // })
    // @todo generate AngularComponent
    // @todo generate AngularModule
  }
}

class AngularComponent {
  constructor(private componentMetadata: ComponentMetadata, private options: AngularComponentsOptions) {}
  
  get import(): string {
    return this.options.componentImport(this.componentMetadata);
  }

  get tag(): string {
    return this.options.componentTag ? this.options.componentTag(this.componentMetadata) : "";
  }

  get inputs() {
    const propertyDescription = (property: ComponentPropertyMetadata): string => property.description ? `  /** ${property.description} */` : '';
    const propertyDeclarationWithoutDefault = (property: ComponentPropertyMetadata): string => `  @Input() ${property.name}!: ${property.type};`;
    const propertyDeclarationWithDefault = (property: ComponentPropertyMetadata): string => `  @Input() ${property.name}: ${property.type} = ${typeof property.default === 'string' ? `"${property.default}"` : JSON.stringify(property.default) };`;
    const propertyDeclaration = (property: ComponentPropertyMetadata): string => property.default ? propertyDeclarationWithDefault(property) : propertyDeclarationWithoutDefault(property);

    const createInput = (property: ComponentPropertyMetadata): string => [
      propertyDescription(property),
      propertyDeclaration(property),
      ''
    ].join('\n');

    return this.componentMetadata.properties.map(createInput).join('');
  }
  
  get template() {
    const attributes = this.componentMetadata.properties.map(property => `[${property.name}]="${property.name}"`).join(' ');
    
    return `<${this.tag} ${attributes}></${this.tag}>`
  }

  get fileContent(): string {
    return `// Generated by web-component-wrapper
${this.import}
import { Component, Input } from '@angular/core';

${this.componentMetadata.typings}

// @todo: rewrite to Directive
${this.componentMetadata.description ? `/** ${this.componentMetadata.description} */` : ''}
@Component({
  selector: 'custom-tag',
  template: \`${this.template}\`
})
export class ${this.componentMetadata.className}Component {
${this.inputs}
}
    `
  }

  generate(config: Config) {
    const destFilePath = join(config.dist, 'components', `${this.componentMetadata.className}.component.ts`);

    if (!existsSync(dirname(destFilePath))) {
      mkdirSync(dirname(destFilePath), { recursive: true });
    }

    writeFileSync(destFilePath, this.fileContent, { encoding: 'utf-8'});
  }
}

class AngularModule {}
